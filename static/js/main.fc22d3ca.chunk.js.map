{"version":3,"sources":["components/Statistics.tsx","components/data-set/DataSetDisplay.tsx","components/sort/algorithms/HelperMethods.ts","components/sort/algorithms/BubbleSort.ts","components/sort/algorithms/SelectionSort.ts","components/sort/algorithms/InsertionSort.ts","components/sort/algorithms/MergeSort.ts","components/sort/algorithms/QuickSort.ts","components/sort/algorithms/HeapSort.ts","components/sort/SortAnimator.ts","components/data-set/DataSetState.ts","components/data-set/DataSetInputs.tsx","components/sort/SortButtons.tsx","components/sort/SortDataInputs.tsx","components/TitleCard.tsx","components/Toolbar.tsx","components/info-box/AlgoInfo.ts","components/info-box/InfoBox.tsx","components/info-box/InfoBoxState.ts","App.tsx","index.tsx"],"names":["Statistics","props","className","length","statistics","comparisons","swaps","calculateHeight","dataSet","value","Math","max","DataSetDisplay","dataSize","width","map","index","style","height","margin","swap","i","j","anim","push","temp","BubbleSort","animations","sortedData","slice","didSwap","SelectionSort","minIndex","InsertionSort","key","mergeSortHelper","arr","low","high","mid","floor","merge","k","MergeSort","sortedArray","getRandomPivotIndex","random","lomutoHelper","partitionIndex","lomutoPartition","randIndex","pivot","hoareHelper","hoarePartition","left","right","QuickSort","isLomuto","generateMaxHeap","size","idx","largest","compareAnimation","HeapSort","sortedSet","heapSize","PRIMARY_COLOR","baseSpeed","SortAnimator","useState","animating","setAnimating","isSorted","setIsSorted","setComparisons","setSwaps","ANIMATION_SPEED","multiplier","finishSorting","dataBars","num","min","animSpeed","setTimeout","backgroundColor","animateSort","slowFactor","speed","document","getElementsByClassName","lastKeyIndex","localComparisons","localSwaps","statUpdateSpeed","updateStats","setInterval","type","barOneIndex","barTwoIndex","barOneStyles","hasValidBarTwo","Number","isInteger","barTwoStyles","clearInterval","barOneHeight","newHeight","console","error","functions","sortData","algorithm","setBaseSpeed","e","parseFloat","target","resetSorted","properties","generateData","data","DataSetState","initialValue","setDataSet","resetStyling","handleChange","input","newSize","ceil","oldData","regenerateNewData","undoSort","setResetSorted","func","DataSetInputs","display","isDisabled","defaultValue","onInput","onChange","disabled","onClick","id","marginLeft","SortButtons","name","selectedAlgo","changeAlgo","label","sortProps","infoState","setAlgo","toggleInfoBox","SortDataInputs","setSelectedAlgo","step","setSpeed","TitleCard","href","rel","Toolbar","animState","dataState","AlgoInfo","bubble","url","selection","insertion","quick_lom","quick_hor","heap","InfoBox","isEnabled","src","algoInfo","title","InfoBoxState","setEnabled","setAlgoInfo","enabled","undefined","algo","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.fc22d3ca.chunk.js","sourcesContent":["type StatisticsProps = {\n  statistics: {\n    comparisons: number;\n    swaps: number;\n  };\n  length: number;\n};\n\n/**\n * @param props Containes information about the data set's size,\n * as well as the number of comparisons and swaps during sorting.\n * @returns A small two-line piece of text showing information about\n * the data set.\n */\nconst Statistics = (props: StatisticsProps) => {\n  return (\n    <div className=\"statistics\">\n      <h3>There are {props.length} random elements in the data set</h3>\n      <h4>\n        Comparisons: {props.statistics.comparisons} | Swaps & Insertions:{' '}\n        {props.statistics.swaps}\n      </h4>\n    </div>\n  );\n};\n\nexport default Statistics;\n","import Statistics from '../Statistics';\n\ninterface DataSetProps {\n  dataSet: number[];\n  statistics: {\n    comparisons: number;\n    swaps: number;\n  };\n}\n\nconst MAX_HEIGHT = 72;\n\n/**\n * Calculates the height for a given data point and its respective bar.\n * @param dataSet The current data set.\n * @param value The value of the element within the data set.\n * @returns A height value (in vh) to be applied to the data bar in CSS.\n */\nexport const calculateHeight = (dataSet: number[], value: number) => {\n  return (value * MAX_HEIGHT) / Math.max(...dataSet);\n};\n\n/**\n * Calculates the width for each data bar.\n * @param dataSize The number of points in the data set.\n * @param maxWidth The maximum width (in vw) of the whold bar graph.\n * @returns A width value (in vw) to be applied to the data bar in CSS.\n */\nconst calculateWidth = (dataSize: number, maxWidth: number) => {\n  return maxWidth / (1.1 * (dataSize - 1));\n};\n\n/**\n * Generates the 'bar graph'/display of data points.\n * @param props Contains information about the data set,\n * as well as the number of comparisons and swaps during sorting.\n * @returns A bar graph representing all of the data points in the set.\n */\nconst DataSetDisplay = (props: DataSetProps) => {\n  let width = calculateWidth(props.dataSet.length, 85);\n  return (\n    <div className=\"data_container\">\n      <Statistics statistics={props.statistics} length={props.dataSet.length} />\n      <div className=\"data_set\">\n        {props.dataSet.map((value, index) => {\n          return (\n            <div\n              className=\"data_bar\"\n              key={index}\n              style={{\n                height: `${calculateHeight(props.dataSet, value)}vh`,\n                width: `${width}vw`,\n                margin: `0 ${width / 10}vw`\n              }}\n            ></div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\nexport default DataSetDisplay;\n","// A list of functions commonly used in these algorithms:\n\n/**\n * Swaps two elements in an array\n * and push that animation into the animation array.\n * @param dataSet An array.\n * @param i Index of one element to be swapped.\n * @param j Index of the other element to be swapped.\n * @param anim The 2D animations array to push swap animations into.\n */\nexport const swap = (\n  dataSet: number[],\n  i: number,\n  j: number,\n  anim: (string | number)[][]\n) => {\n  anim.push(['swap', i, j]);\n  const temp = dataSet[i];\n  dataSet[i] = dataSet[j];\n  dataSet[j] = temp;\n};\n","import { swap } from './HelperMethods';\n\n/**\n * Bubble sorts a deep copy of the original data set.\n * @param dataSet The current data set.\n * @returns An 2D animations array that contains the information\n * necessary for SortAnimator.ts to animating bubble sort.\n */\nconst BubbleSort = (dataSet: number[]) => {\n  const animations: (string | number)[][] = [];\n\n  if (dataSet.length <= 1) return animations;\n\n  const sortedData = dataSet.slice();\n  const dataSize = sortedData.length;\n\n  for (let i = 0; i < dataSize - 1; i++) {\n    // For fast bubble sort, if it goes through an array pass\n    // without swapping, then it means the data set is fully sorted.\n    let didSwap = false;\n\n    // Loop through the unsorted part of the data set.\n    for (let j = 0; j < dataSize - i - 1; j++) {\n      animations.push(['compare', j, j + 1]);\n\n      if (sortedData[j] > sortedData[j + 1]) {\n        swap(sortedData, j, j + 1, animations);\n        didSwap = true;\n      }\n    }\n\n    // Highlights the last sorted element in the data set.\n    animations.push(['key', dataSize - i - 1]);\n\n    // If a pass if completed without swapping, immedietely return\n    // as sorting is finished.\n    if (!didSwap) return animations;\n  }\n\n  return animations;\n};\n\nexport default BubbleSort;\n","import { swap } from './HelperMethods';\n\n/**\n * Selection sorts a deep copy of the data set.\n * @param dataSet The current data set.\n * @returns A 2D animations array containing the information\n * needed for SortAnimator.ts to animate selection sort.\n */\nconst SelectionSort = (dataSet: number[]) => {\n  const sortedData = dataSet.slice();\n  const animations: (string | number)[][] = [];\n\n  if (sortedData.length <= 1) return animations;\n\n  for (let i = 0; i < sortedData.length - 1; i++) {\n    let minIndex = i;\n    // Highlight the division between the sorted and unsorted sets.\n    animations.push(['key', i]);\n\n    for (let j = i + 1; j < sortedData.length; j++) {\n      if (sortedData[j] < sortedData[minIndex]) minIndex = j;\n      animations.push(['compare', minIndex, j]);\n    }\n\n    swap(sortedData, i, minIndex, animations);\n  }\n\n  return animations;\n};\n\nexport default SelectionSort;\n","/**\n * Insertion sorts a deep copy of the data set.\n * @param dataSet The current data set.\n * @returns A 2D animations array containing the information\n * needed for SortAnimator.ts to animate insertion sort.\n */\nconst InsertionSort = (dataSet: number[]) => {\n  const sortedData = dataSet.slice();\n  const animations: (string | number)[][] = [];\n\n  if (sortedData.length <= 1) return animations;\n\n  for (let i = 1; i < sortedData.length; i++) {\n    let key = sortedData[i];\n    let j = i - 1;\n\n    // Highlights the division between the sorted and unsorted sets.\n    if (i < sortedData.length - 1) animations.push(['key', i]);\n    animations.push(['compare', j, j + 1]);\n\n    // Keep moving the data point back until the element left of it\n    // is less than its value (sorted order).\n    while (j >= 0 && sortedData[j] > key) {\n      animations.push(['swap', j, j + 1]);\n      sortedData[j + 1] = sortedData[j];\n      sortedData[j] = key;\n      j--;\n      // If the loop will run again, add another comparison animation.\n      if (sortedData[j] > key) animations.push(['compare', j, j + 1]);\n    }\n  }\n\n  return animations;\n};\n\nexport default InsertionSort;\n","// Taken from\n// https://runestone.academy/runestone/books/published/apcsareview/searchsort/mergesort.html\n// * Based on the AP Computer Science A course\n// * Originally in Java, adapted for TypeScript\n// (also basically the same from Clement's visualizer/AlgoExpert.io)\n\n/**\n * Merge sorts a deep copy of the data set.\n * @param dataSet The current data set.\n * @returns A 2D animations array containing the information\n * needed for SortAnimator.ts to animate merge sort.\n */\nconst MergeSort = (dataSet: number[]) => {\n  const animations: (string | number)[][] = [];\n\n  if (dataSet.length <= 1) return animations;\n\n  const sortedArray = dataSet.slice();\n  const temp = dataSet.slice();\n\n  mergeSortHelper(sortedArray, 0, sortedArray.length - 1, temp, animations);\n\n  return animations;\n};\n\n/**\n * Recursively merge sortes the deep copy of the data set.\n * @param arr The current section of the array to be sorted.\n * @param low The left most index of sorting.\n * @param high The right most index of sorting.\n * @param temp A temporary array to store values, which will\n * later be insorted into the sorted set.\n * @param anim The 2D animations array.\n */\nconst mergeSortHelper = (\n  arr: number[],\n  low: number,\n  high: number,\n  temp: number[],\n  anim: (string | number)[][]\n) => {\n  if (low < high) {\n    const mid = Math.floor((low + high) / 2);\n    mergeSortHelper(temp, low, mid, arr, anim);\n    mergeSortHelper(temp, mid + 1, high, arr, anim);\n    merge(arr, low, mid, high, temp, anim);\n  }\n};\n\n/**\n * Merges the two partitions into their sorted positions in the data set.\n * @param arr The current section of the array to put sorted values into.\n * @param low The left most index of the data set to be sorted.\n * @param mid The mid point index of the data set section.\n * @param high The right most index of the data set to be sorted.\n * @param temp A temporary array to store values, which are to be merged\n * with arr.\n * @param anim The 2D animations array.\n */\nconst merge = (\n  arr: number[],\n  low: number,\n  mid: number,\n  high: number,\n  temp: number[],\n  anim: (string | number)[][]\n) => {\n  let i = low;\n  let j = mid + 1;\n  let k = low;\n\n  // Highlight the mid point\n  // AKA the the divider between two partitions\n  // which are to be merged together.\n  anim.push(['key', mid]);\n\n  // Move elements from the left and right partitions\n  // (stored in the temp array)\n  // into their sorted positions, alternating between them.\n  while (i <= mid && j <= high) {\n    anim.push(['compare', i, j]);\n\n    if (temp[i] < temp[j]) {\n      anim.push(['swap', k, temp[i]]);\n      arr[k] = temp[i];\n      i++;\n    } else {\n      anim.push(['swap', k, temp[j]]);\n      arr[k] = temp[j];\n      j++;\n    }\n\n    k++;\n  }\n\n  // Move any remaining elements from the left partition\n  while (i <= mid) {\n    anim.push(['swap', k, temp[i]]);\n    arr[k] = temp[i];\n    i++;\n    k++;\n  }\n\n  // Move any remaining elements from the right partition\n  while (j <= high) {\n    anim.push(['swap', k, temp[j]]);\n    arr[k] = temp[j];\n    j++;\n    k++;\n  }\n};\n\nexport default MergeSort;\n","import { swap } from './HelperMethods';\n\n/**\n * Generates a random index to pick out a pivot for quick sort.\n * @param low The lower boundary.\n * @param high The upper boundary.\n * @returns A random integer between low and high (inclusive).\n */\nconst getRandomPivotIndex = (low: number, high: number) =>\n  Math.floor(Math.random() * (high - low + 1)) + low;\n\n/**\n * Quick sorts a deep copy of the data set.\n *\n * Code adapted from https://www.geeksforgeeks.org/quicksort-using-random-pivoting/\n *\n * @param dataSet The current data set.\n * @param isLomuto Switch between Lomuto's partitioning scheme, or Hoare's\n * partitioning scheme.\n * @returns A 2D animations array containing the information\n * needed for SortAnimator.ts to animate quick sort.\n */\nconst QuickSort = (dataSet: number[], isLomuto: boolean) => {\n  const animations: (string | number)[][] = [];\n\n  if (dataSet.length <= 1) return animations;\n\n  const sortedData = dataSet.slice();\n\n  if (isLomuto) lomutoHelper(sortedData, 0, sortedData.length - 1, animations);\n  else hoareHelper(sortedData, 0, sortedData.length - 1, animations);\n\n  return animations;\n};\n\n// LOMUTO PARTITIONING\n\n/**\n * Recursively quick sorts two halves of the data set,\n * using Lomuto's partitioning scheme.\n * @param dataSet The deep copy of the original data set.\n * @param low The left index boundary of the partition.\n * @param high The right index booundary of the partition.\n * @param anim The 2D animation array.\n */\nconst lomutoHelper = (\n  dataSet: number[],\n  low: number,\n  high: number,\n  anim: (string | number)[][]\n) => {\n  if (low < high) {\n    const partitionIndex = lomutoPartition(dataSet, low, high, anim);\n\n    lomutoHelper(dataSet, low, partitionIndex - 1, anim);\n    lomutoHelper(dataSet, partitionIndex + 1, high, anim);\n  }\n};\n\n/**\n * Scans the data set from low -> high, moving all the elements\n * less than the pivot to its left, and greater elements to its right.\n * @param dataSet The deep copy of the data set.\n * @param low The left index boundary of the partition.\n * @param high The right index boundary of the partition.\n * @param anim The 2D animations array.\n * @returns The index of the pivot, used by lomutoHelper\n * to divide and conquer.\n */\nconst lomutoPartition = (\n  dataSet: number[],\n  low: number,\n  high: number,\n  anim: (string | number)[][]\n) => {\n  // Partitioning uses the last element (high index) of a section as the pivot\n  // Here, the last element is swapped with a random element\n  const randIndex = getRandomPivotIndex(low, high);\n  anim.push(['key', randIndex]);\n  swap(dataSet, randIndex, high, anim);\n  const pivot = dataSet[high];\n\n  let i = low - 1; // Index of smallest value immediately left of the pivot\n\n  // Scans through the data set between the low and high indeces\n  for (let j = low; j < high; j++) {\n    // If current element is smaller/equal to pivot\n    if (dataSet[j] < pivot) {\n      i++; // Increment the index of the smallest value\n      anim.push(['compare', i, j]);\n      swap(dataSet, i, j, anim); // Swap\n    }\n  }\n\n  // Swap the element at index i + 1\n  // which should be the first element bigger than the pivot,\n  // with the pivot which is now placed at the high index.\n  anim.push(['compare', i + 1, high]);\n  swap(dataSet, i + 1, high, anim);\n\n  return i + 1;\n};\n\n// HOARE PARTITIONING\n\n/**\n * Recursively quick sorts the two halves of the data set,\n * using Hoare's partitioning scheme.\n * @param dataSet The deep copy of the data set.\n * @param low The left index boundary of the partition.\n * @param high The right index boundary of the partition.\n * @param anim The 2D animations array.\n */\nconst hoareHelper = (\n  dataSet: number[],\n  low: number,\n  high: number,\n  anim: (string | number)[][]\n) => {\n  if (low < high) {\n    const partitionIndex = hoarePartition(dataSet, low, high, anim);\n    hoareHelper(dataSet, low, partitionIndex, anim);\n    hoareHelper(dataSet, partitionIndex + 1, high, anim);\n  }\n};\n\n/**\n * Two left and right pointers converge on each other until they find\n * a value that is not sorted relative to the pivot. At that point, they\n * swap elements and repeats until the left pointer crosses the right pointer.\n * @param dataSet The deep copy of the data set.\n * @param low The starting point of the left index pointer.\n * @param high The starting point of the right index pointer.\n * @param anim The 2D animations array.\n * @returns A partitioning index to be used by hoareHelper to\n * divide and conquer.\n */\nconst hoarePartition = (\n  dataSet: number[],\n  low: number,\n  high: number,\n  anim: (string | number)[][]\n) => {\n  // Partitioning uses the first element (low index) of a section as the pivot\n  // Here, the last element is swapped with a random element\n  const randIndex = getRandomPivotIndex(low, high);\n  swap(dataSet, randIndex, low, anim);\n  const pivot = dataSet[low];\n  anim.push(['key', randIndex]);\n\n  // Hoare partitioning uses two pointers: i and j;\n  // That start from left and right and converge until\n  // They reach an unsorted value (relative to pivot)\n  //  - Left pointer moves until it finds the first value >= than pivot\n  //  - Right pointer moves until it finds the first value <= than pivot\n  let left = low;\n  let right = high;\n\n  while (true) {\n    // Moves left pointer until it finds a value >= pivot.\n    while (dataSet[left] < pivot) left++;\n\n    // Moves right pointer until it finds a value <= pivot.\n    while (dataSet[right] > pivot) right--;\n\n    anim.push(['compare', left, right]);\n\n    // Once left and right pointers cross eachother,\n    // The correct partition index is found and thus return it\n    // to partition the data set into two sections:\n    //  - Left half < pivot\n    //  - Right half > pivot\n    if (left >= right) return right;\n\n    // Swap the greater-than-pivot left element\n    // with the smaller-than-pivot right element\n    swap(dataSet, left, right, anim);\n  }\n};\n\nexport default QuickSort;\n","import { swap } from './HelperMethods';\n\n/**\n * Heap sorts a deep copy of the data set.\n * @param dataSet The current data set.\n * @returns A 2D animations array containing the information\n * needed for SortAnimator.ts to animate heap sort.\n */\nconst HeapSort = (dataSet: number[]) => {\n  const animations: (string | number)[][] = [];\n\n  const sortedSet = dataSet.slice();\n  let heapSize = sortedSet.length;\n  if (heapSize <= 1) return animations;\n\n  // Generate the initial max heap.\n  for (let i = Math.floor(heapSize / 2) - 1; i >= 0; i--) {\n    generateMaxHeap(sortedSet, heapSize, i, animations);\n  }\n\n  // Move the root of the tree (largest element) to the very end\n  // of the data set, and generate another max heap with\n  // the remaining elements.\n  for (let i = heapSize - 1; i > 0; i--) {\n    animations.push(['key', i]);\n    swap(sortedSet, i, 0, animations);\n    generateMaxHeap(sortedSet, i, 0, animations);\n  }\n  return animations;\n};\n\n/**\n * Generates a max heap in which the parent node has a greater value\n * than any of its child nodes.\n * @param dataSet The deep copy of the data set.\n * @param size The size of the heap/unsorted section.\n * @param idx The index of the parent node.\n * @param anim The 2D animations array.\n */\nconst generateMaxHeap = (\n  dataSet: number[],\n  size: number,\n  idx: number,\n  anim: (string | number)[][]\n) => {\n  const left = idx * 2 + 1; // Left node index.\n  const right = idx * 2 + 2; // Right node index.\n  let largest = idx; // Parent node (which should be largest in a max heap).\n\n  const compareAnimation: (string | number)[] = ['compare'];\n\n  // Finds a child node that is greater than its parent.\n  if (left < size) {\n    compareAnimation.push(left);\n    if (dataSet[left] > dataSet[largest]) largest = left;\n  }\n  if (right < size) {\n    compareAnimation.push(right);\n    if (dataSet[right] > dataSet[largest]) largest = right;\n  }\n\n  if (compareAnimation.length > 1) anim.push(compareAnimation);\n\n  // Swaps a root node with its child node\n  // if its child is larger than its parent.\n  if (largest !== idx) {\n    swap(dataSet, idx, largest, anim);\n    // Recursively build the max heap from top (root) to bottom\n    generateMaxHeap(dataSet, size, largest, anim);\n  }\n};\n\nexport default HeapSort;\n","/* eslint-disable no-loop-func */\nimport React, { useState } from 'react';\n\nimport { calculateHeight } from '../data-set/DataSetDisplay';\n\nimport BubbleSort from './algorithms/BubbleSort';\nimport SelectionSort from './algorithms/SelectionSort';\nimport InsertionSort from './algorithms/InsertionSort';\nimport MergeSort from './algorithms/MergeSort';\nimport QuickSort from './algorithms/QuickSort';\nimport HeapSort from './algorithms/HeapSort';\n\nexport type AlgorithmType =\n  | 'bubble'\n  | 'selection'\n  | 'insertion'\n  | 'merge'\n  | 'quick_lom'\n  | 'quick_hor'\n  | 'heap'\n  | undefined;\n\n// Main Colors\nexport const PRIMARY_COLOR = 'steelblue';\nconst COMPARISON_COLOR = 'yellow';\nconst KEY_COLOR = 'magenta';\nconst KEY_COLOR_TWO = 'crimson';\nconst SORTED_COLOR = 'seagreen';\n\nlet baseSpeed = 2;\n\n/**\n * Clamps a number between a range of values:\n * (Can't go over or under a certain range).\n * @param num Value to be clamped.\n * @param min Minimum value.\n * @param max Maximum value.\n * @returns The value, num, clamped within a certain range.\n */\nconst clamp = (num: number, min: number, max: number) =>\n  Math.min(Math.max(num, min), max);\n\n/**\n * Animates the sorting and manages the animation state.\n * @param dataSet The current data set.\n * @returns A collection of useful properties and functions.\n */\nconst SortAnimator = (dataSet: number[]) => {\n  // States used to disable user input\n  const [animating, setAnimating] = useState(false);\n  const [isSorted, setIsSorted] = useState(false);\n\n  // States used for statistics\n  const [comparisons, setComparisons] = useState(0);\n  const [swaps, setSwaps] = useState(0);\n\n  /**\n   * Resets the data set back to its original unsorted state.\n   */\n  const resetSorted = () => {\n    setIsSorted(false);\n    setComparisons(0);\n    setSwaps(0);\n  };\n\n  /**\n   * Sets the speed of animation via slider.\n   * @param e The slider event.\n   */\n  const setBaseSpeed = (e: React.ChangeEvent<HTMLInputElement>) => {\n    baseSpeed = 1 / parseFloat(e.target.value);\n  };\n\n  /**\n   * Scales animation speed appropriately with the data set size.\n   * such that it takes the same time regardless of size.\n   * @returns The animation speed to be used.\n   */\n  const ANIMATION_SPEED = () => {\n    const multiplier = dataSet.length / 100;\n    return baseSpeed / (multiplier * multiplier);\n  };\n\n  /**\n   * Calls the appropriate sorting algorithm and begins animating.\n   * @param algorithm The algorithm to be used for sorting.\n   */\n  const sortData = (algorithm?: AlgorithmType) => {\n    setAnimating(true);\n    setIsSorted(true);\n\n    let animations: (string | number)[][] = [];\n\n    // Higher value -> Slower animation\n    // slowFactor of 1 is the base speed for selectionSort\n    // Increases for O(nlogn) algos as they are too quick to match speeds\n    let slowFactor = 1;\n\n    switch (algorithm) {\n      case 'bubble':\n        animations = BubbleSort(dataSet);\n        slowFactor = 0.5;\n        break;\n      case 'selection':\n        animations = SelectionSort(dataSet);\n        break;\n      case 'insertion':\n        animations = InsertionSort(dataSet);\n        break;\n      case 'merge':\n        animations = MergeSort(dataSet);\n        slowFactor = 5;\n        break;\n      case 'quick_lom':\n        animations = QuickSort(dataSet, true);\n        slowFactor = 5;\n        break;\n      case 'quick_hor':\n        animations = QuickSort(dataSet, false);\n        slowFactor = 5;\n        break;\n      case 'heap':\n        animations = HeapSort(dataSet);\n        slowFactor = 5;\n        break;\n      default:\n        // Should in theory never happen\n        setIsSorted(false);\n        setAnimating(false);\n        console.error('No algorithm specified :/');\n        return;\n    }\n    animateSort(animations, slowFactor);\n  };\n\n  /*\n  SORTING ALGORITHM ANIMATIONS HERE\n\n  =========================================================\n\n  ALL SORTING ALGORITHMS RETURN AN 'ANIMATION' ARRAY:\n  An animation array is a 2D array that contains the steps\n  done in animating the sorting.\n\n  Each element is an array that containes the following values:\n    - type: string = The kind of operator it is\n        - 'key': Highlights a certain value\n            (pivot, mid point, leading bar, etc.)\n        - 'compare': Highlights two bars which are\n            being compared against each other\n        - 'swap': Swaps heights between bars\n            * for merge sort, only the first bar height is changed\n    - indexOne: number = The index of the first bar\n    - indexTwo: number = The index of the second bar\n        * indexTwo may be a duplicate for 'key' operations,\n            as only one bar is needed\n\n  Sorting then utilizes each element of the animation array to modify the\n  CSS styling of the bars to demonstrate the sorting.\n\n  Note: All animations use a bunch of setTimeouts\n    - Yes, I know it looks horrible, I just don't know any other alternative\n  */\n\n  /**\n   * The final 'green swipe' animation after being sorted.\n   * @param dataBars An array containing the HTMLElements of the data bars.\n   */\n  const finishSorting = (dataBars: HTMLCollectionOf<HTMLElement>) => {\n    const animSpeed = clamp(ANIMATION_SPEED(), 1, 50);\n\n    for (let i = 0; i < dataBars.length; i++) {\n      setTimeout(() => {\n        dataBars[i].style.backgroundColor = SORTED_COLOR;\n        if (i === dataBars.length - 1) {\n          setTimeout(() => {\n            setAnimating(false);\n            setIsSorted(true);\n          }, 1000);\n        }\n      }, i * animSpeed);\n    }\n  };\n\n  /**\n   * Animates the sorting algorithm\n   * @param animations The animations array returned by a sorting algo.\n   * @param slowFactor Slows the speed of animation (Greater value = Slower).\n   */\n  const animateSort = (\n    animations: (string | number)[][],\n    slowFactor: number\n  ) => {\n    const speed = ANIMATION_SPEED() * slowFactor;\n\n    const dataBars = document.getElementsByClassName(\n      'data_bar'\n    ) as HTMLCollectionOf<HTMLElement>;\n\n    let lastKeyIndex = 0;\n\n    let localComparisons = 0;\n    let localSwaps = 0;\n\n    // Instead of updating state immediately after a swap/compare\n    //    * will cause componenet re-renders\n    // It will update at a set frequency instead that scales with the size\n    // of the data set.\n    const statUpdateSpeed = dataSet.length * 1.5;\n    const updateStats = setInterval(() => {\n      setComparisons(localComparisons);\n      setSwaps(localSwaps);\n    }, statUpdateSpeed);\n\n    for (let i = 0; i < animations.length; i++) {\n      const [type, barOneIndex, barTwoIndex] = animations[i];\n      const barOneStyles = dataBars[barOneIndex as number].style;\n\n      // Used to check if a bartwo actually exists\n      const hasValidBarTwo =\n        (barTwoIndex as number) < dataSet.length &&\n        Number.isInteger(barTwoIndex as number);\n      // If barTwoIndex is not, default barTwo to barOne\n      const barTwoStyles =\n        dataBars[\n          hasValidBarTwo ? (barTwoIndex as number) : (barOneIndex as number)\n        ].style;\n\n      switch (type) {\n        case 'key': // Highlight the key\n          setTimeout(() => {\n            if (lastKeyIndex !== barOneIndex) {\n              dataBars[lastKeyIndex as number].style.backgroundColor =\n                PRIMARY_COLOR;\n              barOneStyles.backgroundColor = KEY_COLOR_TWO;\n              lastKeyIndex = barOneIndex as number;\n            }\n            if (i === animations.length - 1) {\n              setComparisons(localComparisons);\n              setSwaps(localSwaps);\n              finishSorting(dataBars);\n              clearInterval(updateStats);\n            }\n          }, i * speed);\n          break;\n        case 'compare': // Color the two bars being compared\n          setTimeout(() => {\n            localComparisons++;\n            if (barOneIndex !== lastKeyIndex)\n              barOneStyles.backgroundColor = COMPARISON_COLOR;\n            if (barTwoIndex !== lastKeyIndex)\n              barTwoStyles.backgroundColor = KEY_COLOR;\n          }, i * speed);\n          setTimeout(() => {\n            if (barOneIndex !== lastKeyIndex)\n              barOneStyles.backgroundColor = PRIMARY_COLOR;\n            if (barTwoIndex !== lastKeyIndex)\n              barTwoStyles.backgroundColor = PRIMARY_COLOR;\n            if (i === animations.length - 1) {\n              dataBars[lastKeyIndex as number].style.backgroundColor =\n                PRIMARY_COLOR;\n              setComparisons(localComparisons);\n              setSwaps(localSwaps);\n              finishSorting(dataBars);\n              clearInterval(updateStats);\n            }\n          }, (i + 1) * speed);\n          break;\n        case 'swap': // Swap heights of the two bars\n          setTimeout(() => {\n            localSwaps++;\n            if (hasValidBarTwo) {\n              const barOneHeight = barOneStyles.height;\n              barOneStyles.height = barTwoStyles.height;\n              barTwoStyles.height = barOneHeight;\n            } else {\n              // For merge sort which does not involve swapping,\n              // and the fact it refrences a temp array for swaps,\n              // barOne's height is instead directly changed to the value\n              // held by temp array (stored as barTwoIndex)\n              const newHeight = calculateHeight(dataSet, barTwoIndex as number);\n              barOneStyles.height = `${newHeight}vh`;\n            }\n            if (i === animations.length - 1) {\n              dataBars[lastKeyIndex as number].style.backgroundColor =\n                PRIMARY_COLOR;\n              setComparisons(localComparisons);\n              setSwaps(localSwaps);\n              finishSorting(dataBars);\n              clearInterval(updateStats);\n            }\n          }, i * speed);\n          break;\n        default:\n          console.error('Unknown operator??????');\n          break;\n      }\n    }\n  };\n\n  // Grouping things for better readability\n  const statistics = {\n    comparisons,\n    swaps\n  };\n\n  const functions = {\n    sortData,\n    setBaseSpeed,\n    resetSorted\n  };\n\n  const properties = {\n    animating,\n    isSorted,\n    statistics\n  };\n\n  return { functions, properties };\n};\n\nexport default SortAnimator;\n","import React, { useState } from 'react';\nimport { PRIMARY_COLOR } from '../sort/SortAnimator';\nimport { calculateHeight } from './DataSetDisplay';\n\n/**\n * Randomly generates an array (data set) of given size and max value.\n * @param size The number of bars / size of data set.\n * @param height The maximum value of data (used for scaling bars).\n * @returns A randomly generated data set.\n */\nconst generateData = (size: number, height: number): number[] => {\n  let data: number[] = [size];\n  for (let i = 0; i < size; i++) {\n    data[i] = Math.random() * height + 1;\n  }\n  return data;\n};\n\n// The increment in which the data size grows\nconst INCREMENT = 25;\n\n/**\n * Manages the state of the data set (the bars).\n * @param initialValue The initial size of the data set\n * (default = 100).\n * @param height The max value of data set values\n * (between 1 and height, inclusive).\n * @returns A collection of useful properties and functions.\n */\nconst DataSetState = (initialValue: number, height: number) => {\n  const [dataSet, setDataSet] = useState(generateData(initialValue, height));\n\n  let resetSorted: () => void;\n\n  /**\n   * Gives DataSetState access to the reset function in SortAnimator\n   * (yes, its jank).\n   * @param func The reset function found in the animState.\n   */\n  const setResetSorted = (func: () => void) => {\n    resetSorted = func;\n  };\n\n  /**\n   * Generates a new data set with a size set by the slider.\n   * Also resets the styling of the bars\n   * @param e The slider event.\n   */\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const input = parseFloat(e.target.value);\n    const newSize = Math.ceil(input / INCREMENT) * INCREMENT;\n\n    setDataSet((oldData) => generateData(newSize, height));\n    resetStyling();\n  };\n\n  /**\n   * Generates a new data set with the same size as previous.\n   */\n  const regenerateNewData = () => {\n    setDataSet((oldData) => generateData(oldData.length, height));\n    resetStyling();\n  };\n\n  /**\n   * Resets data set back to before it was sorted.\n   */\n  const undoSort = () => {\n    resetStyling();\n\n    const dataBars = document.getElementsByClassName(\n      'data_bar'\n    ) as HTMLCollectionOf<HTMLElement>;\n\n    for (let i = 0; i < dataBars.length; i++) {\n      dataBars[i].style.height = `${calculateHeight(dataSet, dataSet[i])}vh`;\n    }\n  };\n\n  /**\n   * Resets the styling of the data bars.\n   */\n  const resetStyling = () => {\n    resetSorted();\n\n    const dataBars = document.getElementsByClassName(\n      'data_bar'\n    ) as HTMLCollectionOf<HTMLElement>;\n\n    for (let i = 0; i < dataBars.length; i++)\n      dataBars[i].style.backgroundColor = PRIMARY_COLOR;\n  };\n\n  // Organizing things\n  const functions = {\n    handleChange,\n    regenerateNewData,\n    undoSort,\n    setResetSorted\n  };\n\n  return { functions, dataSet };\n};\n\nexport default DataSetState;\n","import React from 'react';\n\ninterface DataProps {\n  dataSize: {\n    handleChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\n    regenerateNewData: () => void;\n    undoSort: () => void;\n  };\n  isDisabled: boolean;\n  isSorted: boolean;\n}\n\n/**\n * @param props Necessary functions and state variables.\n * @returns The slider and buttons that affect the data set.\n */\nconst DataSetInputs = (props: DataProps) => {\n  return (\n    <div\n      className=\"input_section\"\n      style={{ display: props.isDisabled ? 'none' : 'inline' }}\n    >\n      <h3>Generate Data:</h3>\n      <input\n        type=\"range\"\n        className=\"slider data\"\n        min={25}\n        max={500}\n        defaultValue={100}\n        onInput={props.dataSize.handleChange}\n        onChange={props.dataSize.handleChange}\n        disabled={props.isDisabled}\n      />\n      <div className=\"button_list array_button\">\n        <button\n          onClick={props.dataSize.regenerateNewData}\n          disabled={props.isDisabled}\n        >\n          Make New Array\n        </button>\n        <button\n          id=\"undo_sort\"\n          onClick={props.dataSize.undoSort}\n          disabled={!props.isSorted || props.isDisabled}\n          style={{\n            display:\n              !props.isSorted || props.isDisabled ? 'none' : 'inline-block',\n            marginLeft: '1rem'\n          }}\n        >\n          Undo Sort\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default DataSetInputs;\n","import React from 'react';\nimport { AlgorithmType } from './SortAnimator';\n\ntype SortButtonsProps = {\n  selectedAlgo: AlgorithmType;\n  changeAlgo: (e: React.ChangeEvent<HTMLSelectElement>) => void;\n  sortProps: {\n    sortData: (algorithm?: AlgorithmType) => void;\n    isSorted: boolean;\n    isDisabled: boolean;\n    infoState: {\n      toggleInfoBox: (enabled?: boolean) => void;\n      setAlgo: (algo: AlgorithmType) => void;\n    };\n  };\n};\n\n/**\n * @param props Contains multiple functions triggered by the slider,\n * as well as properties (selectedAlgo, isSorted & isDisabled) to\n * determine behavior.\n * @returns The input box that contains inputs which manipulate sorting.\n */\nconst SortButtons = (props: SortButtonsProps) => {\n  return (\n    <div className=\"button_list sort_button\">\n      <select\n        name=\"algos\"\n        id=\"algo-drop\"\n        value={props.selectedAlgo}\n        onChange={props.changeAlgo}\n      >\n        <optgroup label=\"O(n²)\">\n          <option value=\"bubble\">Bubble Sort</option>\n          <option value=\"selection\">Selection Sort</option>\n          <option value=\"insertion\">Insertion Sort</option>\n        </optgroup>\n        <optgroup label=\"O(n·log(n))\">\n          <option value=\"merge\">Merge Sort</option>\n          <option value=\"quick_lom\">Quick Sort (Lomuto Partitioning)</option>\n          <option value=\"quick_hor\">Quick Sort (Hoare Partitioning)</option>\n          <option value=\"heap\">Heap Sort</option>\n        </optgroup>\n      </select>\n      <button\n        onClick={() => {\n          props.sortProps.infoState.setAlgo(props.selectedAlgo);\n          props.sortProps.infoState.toggleInfoBox();\n        }}\n      >\n        Algo Info\n      </button>\n      <button\n        onClick={() => props.sortProps.sortData(props.selectedAlgo)}\n        disabled={props.sortProps.isDisabled || props.sortProps.isSorted}\n        style={{\n          display:\n            props.sortProps.isDisabled || props.sortProps.isSorted\n              ? 'none'\n              : 'inline'\n        }}\n      >\n        Sort Data\n      </button>\n    </div>\n  );\n};\n\nexport default SortButtons;\n","import React, { useState } from 'react';\nimport { AlgorithmType } from './SortAnimator';\nimport SortButtons from './SortButtons';\n\ninterface ButtonProps {\n  setSpeed: (e: React.ChangeEvent<HTMLInputElement>) => void;\n  sortData: (algorithm?: AlgorithmType) => void;\n  isSorted: boolean;\n  isDisabled: boolean;\n  infoState: {\n    toggleInfoBox: (enabled?: boolean) => void;\n    setAlgo: (algo: AlgorithmType) => void;\n  };\n}\n\nconst SortDataInputs = (props: ButtonProps) => {\n  const [selectedAlgo, setSelectedAlgo] = useState<AlgorithmType>('bubble');\n\n  const changeAlgo = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    props.infoState.setAlgo(e.target.value as AlgorithmType);\n    setSelectedAlgo(e.target.value as AlgorithmType);\n  };\n\n  return (\n    <div\n      className=\"input_section sort_section\"\n      style={{ display: props.isDisabled ? 'none' : 'inline' }}\n    >\n      <h3>Sort Speed:</h3>\n      <input\n        type=\"range\"\n        className=\"slider sort\"\n        min={0.1}\n        max={1.0}\n        step={0.00001}\n        defaultValue={0.5}\n        onInput={props.setSpeed}\n        onChange={props.setSpeed}\n        disabled={props.isDisabled}\n      ></input>\n      <SortButtons\n        selectedAlgo={selectedAlgo}\n        changeAlgo={changeAlgo}\n        sortProps={props}\n      />\n    </div>\n  );\n};\n\nexport default SortDataInputs;\n","/**\n * @returns A simple title card.\n */\nconst TitleCard = () => {\n  return (\n    <div id=\"title\">\n      <h1>Sorting Algorithms</h1>\n      <h4>\n        <i>WARNING: Animation contains flashing lights</i>\n      </h4>\n      <h5>\n        © 2021 John Marcus Mabanta ·{' '}\n        <a\n          href=\"https://github.com/jmmabanta/sort-algo\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Source Code\n        </a>\n      </h5>\n    </div>\n  );\n};\n\nexport default TitleCard;\n","import React from 'react';\nimport DataSetInputs from './data-set/DataSetInputs';\nimport { AlgorithmType } from './sort/SortAnimator';\nimport SortDataInputs from './sort/SortDataInputs';\nimport TitleCard from './TitleCard';\n\ntype ToolbarProps = {\n  dataState: {\n    functions: {\n      handleChange: (e: React.ChangeEvent<HTMLInputElement>) => void;\n      regenerateNewData: () => void;\n      undoSort: () => void;\n    };\n  };\n  animState: {\n    functions: {\n      sortData: (algorithm?: AlgorithmType) => void;\n      setBaseSpeed: (e: React.ChangeEvent<HTMLInputElement>) => void;\n    };\n    properties: {\n      animating: boolean;\n      isSorted: boolean;\n    };\n  };\n  infoState: {\n    toggleInfoBox: (enabled?: boolean) => void;\n    setAlgo: (algo: AlgorithmType) => void;\n  };\n};\n\n/**\n * @param props Contains all of the functions and state necessary to\n * add functionality to all of the input fields.\n * @returns A toolbar of user inputs, found at the bottom of the screen,\n * or front and center on smaller screens.\n */\nconst Toolbar = (props: ToolbarProps) => {\n  return (\n    <div\n      id=\"toolbar\"\n      className={props.animState.properties.animating ? 'hide' : 'show'}\n    >\n      <TitleCard />\n      <DataSetInputs\n        dataSize={props.dataState.functions}\n        isDisabled={props.animState.properties.animating}\n        isSorted={props.animState.properties.isSorted}\n      />\n      <SortDataInputs\n        sortData={props.animState.functions.sortData}\n        setSpeed={props.animState.functions.setBaseSpeed}\n        isDisabled={props.animState.properties.animating}\n        isSorted={props.animState.properties.isSorted}\n        infoState={props.infoState}\n      />\n    </div>\n  );\n};\n\nexport default Toolbar;\n","type AlgoInfoType = {\n  [key: string]: {\n    name: string;\n    url: string;\n  };\n};\n\n/**\n * Contains the wikipedia links to be displayed for each\n * sorting algorithm.\n */\nconst AlgoInfo: AlgoInfoType = {\n  bubble: {\n    name: 'Bubble Sort',\n    url: 'https://en.wikipedia.org/wiki/Bubble_sort'\n  },\n  selection: {\n    name: 'Selection Sort',\n    url: 'https://en.wikipedia.org/wiki/Selection_sort'\n  },\n  insertion: {\n    name: 'Insertion Sort',\n    url: 'https://en.wikipedia.org/wiki/Insertion_sort'\n  },\n  merge: {\n    name: 'Merge Sort',\n    url: 'https://en.wikipedia.org/wiki/Merge_sort'\n  },\n  quick_lom: {\n    name: 'Quick Sort',\n    url: 'https://en.wikipedia.org/wiki/Quick_sort'\n  },\n  quick_hor: {\n    name: 'Quick Sort',\n    url: 'https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme'\n  },\n  heap: {\n    name: 'Heap Sort',\n    url: 'https://en.wikipedia.org/wiki/Heapsort'\n  }\n};\n\nexport default AlgoInfo;\n","import AlgoInfo from './AlgoInfo';\n\ntype InfoBoxProps = {\n  infoState: {\n    isEnabled: boolean;\n    algoInfo: string;\n    toggleInfoBox: (enabled?: boolean) => void;\n  };\n};\n\n/**\n * @param props Contains the state variables of InfoBoxState,\n * and a function to turn off the info box.\n * @returns An information box that includes a wikipedia iframe\n * of the currently selected sorting algorithm.\n */\nconst InfoBox = (props: InfoBoxProps) => {\n  return (\n    <div\n      id=\"infobox\"\n      style={{ display: props.infoState.isEnabled ? 'flex' : 'none' }}\n    >\n      <div id=\"wikipedia\">\n        <iframe\n          src={AlgoInfo[props.infoState.algoInfo].url}\n          title={AlgoInfo[props.infoState.algoInfo].name}\n        ></iframe>\n      </div>\n      <button onClick={() => props.infoState.toggleInfoBox(false)}>X</button>\n      <h2>{AlgoInfo[props.infoState.algoInfo].name} Info</h2>\n    </div>\n  );\n};\nexport default InfoBox;\n","import { useState } from 'react';\nimport { AlgorithmType } from '../sort/SortAnimator';\n\n/**\n * Manages the current algorithm selected in order to display\n * their information in the info box.\n * @returns An object which contains both states, and functions\n * to modify these states.\n */\nconst InfoBoxState = () => {\n  const [isEnabled, setEnabled] = useState(false);\n  const [algoInfo, setAlgoInfo] = useState('bubble');\n\n  const toggleInfoBox = (enabled?: boolean) => {\n    if (enabled === undefined) setEnabled((e) => !e);\n    else setEnabled(enabled);\n  };\n\n  const setAlgo = (algo: AlgorithmType) => {\n    setAlgoInfo(algo as string);\n  };\n\n  return { isEnabled, algoInfo, toggleInfoBox, setAlgo };\n};\n\nexport default InfoBoxState;\n","import DataSetState from './components/data-set/DataSetState';\nimport DataSetDisplay from './components/data-set/DataSetDisplay';\nimport SortAnimator from './components/sort/SortAnimator';\nimport Toolbar from './components/Toolbar';\nimport InfoBox from './components/info-box/InfoBox';\nimport InfoBoxState from './components/info-box/InfoBoxState';\n\n/**\n * @returns The HTML of the full page\n */\nconst App = () => {\n  // Don't change the value 45, it just works :/\n  const dataState = DataSetState(100, 45);\n  const animState = SortAnimator(dataState.dataSet);\n  const infoState = InfoBoxState();\n\n  dataState.functions.setResetSorted(animState.functions.resetSorted);\n\n  return (\n    <div id=\"app\">\n      <DataSetDisplay\n        dataSet={dataState.dataSet}\n        statistics={animState.properties.statistics}\n      />\n      <Toolbar\n        dataState={dataState}\n        animState={animState}\n        infoState={infoState}\n      />\n      <InfoBox infoState={infoState} />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}